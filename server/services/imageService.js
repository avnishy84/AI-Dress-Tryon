const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const { v4: uuidv4 } = require('uuid');

class ImageService {
  constructor() {
    this.resultsDir = path.join(__dirname, '..', 'results');
    this.ensureResultsDirectory();
  }

  // Ensure results directory exists
  ensureResultsDirectory() {
    if (!fs.existsSync(this.resultsDir)) {
      fs.mkdirSync(this.resultsDir, { recursive: true });
    }
  }

  // Save generated try-on result
  async saveResult(tryOnResult) {
    try {
      const resultId = uuidv4();
      const filename = `tryon-${resultId}.png`;
      const filepath = path.join(this.resultsDir, filename);

      // If the result contains base64 image data
      if (tryOnResult.result && tryOnResult.result.imageData) {
        const imageBuffer = Buffer.from(tryOnResult.result.imageData, 'base64');
        await fs.promises.writeFile(filepath, imageBuffer);
      } else {
        // Create a placeholder image for demo purposes
        await this.createPlaceholderImage(filepath);
      }

      return {
        id: resultId,
        filename: filename,
        filepath: filepath,
        url: `/results/${filename}`
      };

    } catch (error) {
      throw new Error(`Failed to save result: ${error.message}`);
    }
  }

  // Create a placeholder image for demo purposes
  async createPlaceholderImage(filepath) {
    try {
      // Create a simple placeholder image using Sharp
      const width = 512;
      const height = 768;
      
      const svg = `
        <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
          <rect width="100%" height="100%" fill="#f0f0f0"/>
          <text x="50%" y="50%" text-anchor="middle" dy=".3em" font-family="Arial, sans-serif" font-size="24" fill="#666">
            Dress Try-On Result
          </text>
          <text x="50%" y="60%" text-anchor="middle" dy=".3em" font-family="Arial, sans-serif" font-size="16" fill="#999">
            Generated by AI
          </text>
        </svg>
      `;

      await sharp(Buffer.from(svg))
        .png()
        .toFile(filepath);

    } catch (error) {
      throw new Error(`Failed to create placeholder image: ${error.message}`);
    }
  }

  // Process and optimize images
  async processImage(inputPath, outputPath, options = {}) {
    try {
      const {
        width = 512,
        height = 768,
        quality = 90,
        format = 'png'
      } = options;

      let processor = sharp(inputPath)
        .resize(width, height, {
          fit: 'cover',
          position: 'center'
        });

      switch (format) {
        case 'jpeg':
        case 'jpg':
          processor = processor.jpeg({ quality });
          break;
        case 'png':
          processor = processor.png({ quality });
          break;
        case 'webp':
          processor = processor.webp({ quality });
          break;
        default:
          processor = processor.png({ quality });
      }

      await processor.toFile(outputPath);
      return outputPath;

    } catch (error) {
      throw new Error(`Image processing failed: ${error.message}`);
    }
  }

  // Extract face from user photo for better try-on results
  async extractFace(userPhotoPath) {
    try {
      // This would typically use a face detection library
      // For now, we'll return the original image path
      return userPhotoPath;
    } catch (error) {
      throw new Error(`Face extraction failed: ${error.message}`);
    }
  }

  // Remove background from dress image
  async removeBackground(dressImagePath) {
    try {
      const outputPath = dressImagePath.replace(/\.[^/.]+$/, '_nobg.png');
      
      // This would typically use a background removal service
      // For now, we'll copy the original image
      await fs.promises.copyFile(dressImagePath, outputPath);
      
      return outputPath;
    } catch (error) {
      throw new Error(`Background removal failed: ${error.message}`);
    }
  }

  // Combine user photo with dress
  async combineImages(userPhotoPath, dressImagePath, outputPath) {
    try {
      // This would be the actual image combination logic
      // For now, we'll create a simple overlay
      
      const userImage = sharp(userPhotoPath);
      const dressImage = sharp(dressImagePath);
      
      const { width, height } = await userImage.metadata();
      
      await userImage
        .composite([{
          input: await dressImage.toBuffer(),
          blend: 'over'
        }])
        .png()
        .toFile(outputPath);
      
      return outputPath;
    } catch (error) {
      throw new Error(`Image combination failed: ${error.message}`);
    }
  }

  // Get image metadata
  async getImageMetadata(imagePath) {
    try {
      const metadata = await sharp(imagePath).metadata();
      return {
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
        size: metadata.size,
        channels: metadata.channels,
        density: metadata.density
      };
    } catch (error) {
      throw new Error(`Failed to get image metadata: ${error.message}`);
    }
  }

  // Validate image file
  async validateImage(imagePath) {
    try {
      const metadata = await this.getImageMetadata(imagePath);
      
      // Check if image dimensions are reasonable
      if (metadata.width < 100 || metadata.height < 100) {
        throw new Error('Image too small (minimum 100x100 pixels)');
      }
      
      if (metadata.width > 4000 || metadata.height > 4000) {
        throw new Error('Image too large (maximum 4000x4000 pixels)');
      }
      
      // Check file size (assuming metadata.size is in bytes)
      const maxSize = 10 * 1024 * 1024; // 10MB
      if (metadata.size && metadata.size > maxSize) {
        throw new Error('Image file too large (maximum 10MB)');
      }
      
      return true;
    } catch (error) {
      throw new Error(`Image validation failed: ${error.message}`);
    }
  }

  // Clean up old files
  async cleanupOldFiles(maxAge = 24 * 60 * 60 * 1000) { // 24 hours default
    try {
      const files = await fs.promises.readdir(this.resultsDir);
      const now = Date.now();
      
      for (const file of files) {
        const filePath = path.join(this.resultsDir, file);
        const stats = await fs.promises.stat(filePath);
        
        if (now - stats.mtime.getTime() > maxAge) {
          await fs.promises.unlink(filePath);
          console.log(`Cleaned up old file: ${file}`);
        }
      }
    } catch (error) {
      console.error('Cleanup failed:', error.message);
    }
  }
}

module.exports = new ImageService();
